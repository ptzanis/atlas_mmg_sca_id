# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_primitives', [dirname(__file__)])
        except ImportError:
            import _primitives
            return _primitives
        if fp is not None:
            try:
                _mod = imp.load_module('_primitives', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _primitives = swig_import_helper()
    del swig_import_helper
else:
    import _primitives
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _primitives.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _primitives.SwigPyIterator_value(self)
    def incr(self, n=1): return _primitives.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _primitives.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _primitives.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _primitives.SwigPyIterator_equal(self, *args)
    def copy(self): return _primitives.SwigPyIterator_copy(self)
    def next(self): return _primitives.SwigPyIterator_next(self)
    def __next__(self): return _primitives.SwigPyIterator___next__(self)
    def previous(self): return _primitives.SwigPyIterator_previous(self)
    def advance(self, *args): return _primitives.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _primitives.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _primitives.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _primitives.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _primitives.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _primitives.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _primitives.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _primitives.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class Boolean(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Boolean, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Boolean, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (bool(args[0]),)
            except:
                raise TypeError("'bool' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_Boolean(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.Boolean_value_set
    __swig_getmethods__["value"] = _primitives.Boolean_value_get
    if _newclass:value = _swig_property(_primitives.Boolean_value_get, _primitives.Boolean_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.Boolean_type
    if _newclass:type = staticmethod(_primitives.Boolean_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.Boolean_typeName
    if _newclass:typeName = staticmethod(_primitives.Boolean_typeName)
    def __str__(self): return _primitives.Boolean___str__(self)
    def __eq__(self, *args): return _primitives.Boolean___eq__(self, *args)
    def __ne__(self, *args): return _primitives.Boolean___ne__(self, *args)
    def __lt__(self, *args): return _primitives.Boolean___lt__(self, *args)
    def __gt__(self, *args): return _primitives.Boolean___gt__(self, *args)
    def __ge__(self, *args): return _primitives.Boolean___ge__(self, *args)
    def __le__(self, *args): return _primitives.Boolean___le__(self, *args)
    def __repr__(self): return _primitives.Boolean___repr__(self)
    __swig_destroy__ = _primitives.delete_Boolean
    __del__ = lambda self : None;
Boolean_swigregister = _primitives.Boolean_swigregister
Boolean_swigregister(Boolean)

def Boolean_type():
  return _primitives.Boolean_type()
Boolean_type = _primitives.Boolean_type

def Boolean_typeName():
  return _primitives.Boolean_typeName()
Boolean_typeName = _primitives.Boolean_typeName

class SByte(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SByte, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SByte, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (int(args[0]),)
            except:
                raise TypeError("'int' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_SByte(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.SByte_value_set
    __swig_getmethods__["value"] = _primitives.SByte_value_get
    if _newclass:value = _swig_property(_primitives.SByte_value_get, _primitives.SByte_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.SByte_type
    if _newclass:type = staticmethod(_primitives.SByte_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.SByte_typeName
    if _newclass:typeName = staticmethod(_primitives.SByte_typeName)
    def __str__(self): return _primitives.SByte___str__(self)
    def __eq__(self, *args): return _primitives.SByte___eq__(self, *args)
    def __ne__(self, *args): return _primitives.SByte___ne__(self, *args)
    def __lt__(self, *args): return _primitives.SByte___lt__(self, *args)
    def __gt__(self, *args): return _primitives.SByte___gt__(self, *args)
    def __ge__(self, *args): return _primitives.SByte___ge__(self, *args)
    def __le__(self, *args): return _primitives.SByte___le__(self, *args)
    def __repr__(self): return _primitives.SByte___repr__(self)
    __swig_destroy__ = _primitives.delete_SByte
    __del__ = lambda self : None;
SByte_swigregister = _primitives.SByte_swigregister
SByte_swigregister(SByte)

def SByte_type():
  return _primitives.SByte_type()
SByte_type = _primitives.SByte_type

def SByte_typeName():
  return _primitives.SByte_typeName()
SByte_typeName = _primitives.SByte_typeName

class Byte(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Byte, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Byte, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (int(args[0]),)
            except:
                raise TypeError("'int' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_Byte(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.Byte_value_set
    __swig_getmethods__["value"] = _primitives.Byte_value_get
    if _newclass:value = _swig_property(_primitives.Byte_value_get, _primitives.Byte_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.Byte_type
    if _newclass:type = staticmethod(_primitives.Byte_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.Byte_typeName
    if _newclass:typeName = staticmethod(_primitives.Byte_typeName)
    def __str__(self): return _primitives.Byte___str__(self)
    def __eq__(self, *args): return _primitives.Byte___eq__(self, *args)
    def __ne__(self, *args): return _primitives.Byte___ne__(self, *args)
    def __lt__(self, *args): return _primitives.Byte___lt__(self, *args)
    def __gt__(self, *args): return _primitives.Byte___gt__(self, *args)
    def __ge__(self, *args): return _primitives.Byte___ge__(self, *args)
    def __le__(self, *args): return _primitives.Byte___le__(self, *args)
    def __repr__(self): return _primitives.Byte___repr__(self)
    __swig_destroy__ = _primitives.delete_Byte
    __del__ = lambda self : None;
Byte_swigregister = _primitives.Byte_swigregister
Byte_swigregister(Byte)

def Byte_type():
  return _primitives.Byte_type()
Byte_type = _primitives.Byte_type

def Byte_typeName():
  return _primitives.Byte_typeName()
Byte_typeName = _primitives.Byte_typeName

class Int16(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Int16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Int16, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (int(args[0]),)
            except:
                raise TypeError("'int' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_Int16(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.Int16_value_set
    __swig_getmethods__["value"] = _primitives.Int16_value_get
    if _newclass:value = _swig_property(_primitives.Int16_value_get, _primitives.Int16_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.Int16_type
    if _newclass:type = staticmethod(_primitives.Int16_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.Int16_typeName
    if _newclass:typeName = staticmethod(_primitives.Int16_typeName)
    def __str__(self): return _primitives.Int16___str__(self)
    def __eq__(self, *args): return _primitives.Int16___eq__(self, *args)
    def __ne__(self, *args): return _primitives.Int16___ne__(self, *args)
    def __lt__(self, *args): return _primitives.Int16___lt__(self, *args)
    def __gt__(self, *args): return _primitives.Int16___gt__(self, *args)
    def __ge__(self, *args): return _primitives.Int16___ge__(self, *args)
    def __le__(self, *args): return _primitives.Int16___le__(self, *args)
    def __repr__(self): return _primitives.Int16___repr__(self)
    __swig_destroy__ = _primitives.delete_Int16
    __del__ = lambda self : None;
Int16_swigregister = _primitives.Int16_swigregister
Int16_swigregister(Int16)

def Int16_type():
  return _primitives.Int16_type()
Int16_type = _primitives.Int16_type

def Int16_typeName():
  return _primitives.Int16_typeName()
Int16_typeName = _primitives.Int16_typeName

class UInt16(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UInt16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UInt16, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (int(args[0]),)
            except:
                raise TypeError("'int' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_UInt16(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.UInt16_value_set
    __swig_getmethods__["value"] = _primitives.UInt16_value_get
    if _newclass:value = _swig_property(_primitives.UInt16_value_get, _primitives.UInt16_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.UInt16_type
    if _newclass:type = staticmethod(_primitives.UInt16_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.UInt16_typeName
    if _newclass:typeName = staticmethod(_primitives.UInt16_typeName)
    def __str__(self): return _primitives.UInt16___str__(self)
    def __eq__(self, *args): return _primitives.UInt16___eq__(self, *args)
    def __ne__(self, *args): return _primitives.UInt16___ne__(self, *args)
    def __lt__(self, *args): return _primitives.UInt16___lt__(self, *args)
    def __gt__(self, *args): return _primitives.UInt16___gt__(self, *args)
    def __ge__(self, *args): return _primitives.UInt16___ge__(self, *args)
    def __le__(self, *args): return _primitives.UInt16___le__(self, *args)
    def __repr__(self): return _primitives.UInt16___repr__(self)
    __swig_destroy__ = _primitives.delete_UInt16
    __del__ = lambda self : None;
UInt16_swigregister = _primitives.UInt16_swigregister
UInt16_swigregister(UInt16)

def UInt16_type():
  return _primitives.UInt16_type()
UInt16_type = _primitives.UInt16_type

def UInt16_typeName():
  return _primitives.UInt16_typeName()
UInt16_typeName = _primitives.UInt16_typeName

class Int32(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Int32, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Int32, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (int(args[0]),)
            except:
                raise TypeError("'int' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_Int32(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.Int32_value_set
    __swig_getmethods__["value"] = _primitives.Int32_value_get
    if _newclass:value = _swig_property(_primitives.Int32_value_get, _primitives.Int32_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.Int32_type
    if _newclass:type = staticmethod(_primitives.Int32_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.Int32_typeName
    if _newclass:typeName = staticmethod(_primitives.Int32_typeName)
    def __str__(self): return _primitives.Int32___str__(self)
    def __eq__(self, *args): return _primitives.Int32___eq__(self, *args)
    def __ne__(self, *args): return _primitives.Int32___ne__(self, *args)
    def __lt__(self, *args): return _primitives.Int32___lt__(self, *args)
    def __gt__(self, *args): return _primitives.Int32___gt__(self, *args)
    def __ge__(self, *args): return _primitives.Int32___ge__(self, *args)
    def __le__(self, *args): return _primitives.Int32___le__(self, *args)
    def __repr__(self): return _primitives.Int32___repr__(self)
    __swig_destroy__ = _primitives.delete_Int32
    __del__ = lambda self : None;
Int32_swigregister = _primitives.Int32_swigregister
Int32_swigregister(Int32)

def Int32_type():
  return _primitives.Int32_type()
Int32_type = _primitives.Int32_type

def Int32_typeName():
  return _primitives.Int32_typeName()
Int32_typeName = _primitives.Int32_typeName

class UInt32(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UInt32, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UInt32, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (int(args[0]),)
            except:
                raise TypeError("'int' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_UInt32(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.UInt32_value_set
    __swig_getmethods__["value"] = _primitives.UInt32_value_get
    if _newclass:value = _swig_property(_primitives.UInt32_value_get, _primitives.UInt32_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.UInt32_type
    if _newclass:type = staticmethod(_primitives.UInt32_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.UInt32_typeName
    if _newclass:typeName = staticmethod(_primitives.UInt32_typeName)
    def __str__(self): return _primitives.UInt32___str__(self)
    def __eq__(self, *args): return _primitives.UInt32___eq__(self, *args)
    def __ne__(self, *args): return _primitives.UInt32___ne__(self, *args)
    def __lt__(self, *args): return _primitives.UInt32___lt__(self, *args)
    def __gt__(self, *args): return _primitives.UInt32___gt__(self, *args)
    def __ge__(self, *args): return _primitives.UInt32___ge__(self, *args)
    def __le__(self, *args): return _primitives.UInt32___le__(self, *args)
    def __repr__(self): return _primitives.UInt32___repr__(self)
    __swig_destroy__ = _primitives.delete_UInt32
    __del__ = lambda self : None;
UInt32_swigregister = _primitives.UInt32_swigregister
UInt32_swigregister(UInt32)

def UInt32_type():
  return _primitives.UInt32_type()
UInt32_type = _primitives.UInt32_type

def UInt32_typeName():
  return _primitives.UInt32_typeName()
UInt32_typeName = _primitives.UInt32_typeName

class Int64(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Int64, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Int64, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (long(args[0]),)
            except:
                raise TypeError("'long' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_Int64(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.Int64_value_set
    __swig_getmethods__["value"] = _primitives.Int64_value_get
    if _newclass:value = _swig_property(_primitives.Int64_value_get, _primitives.Int64_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.Int64_type
    if _newclass:type = staticmethod(_primitives.Int64_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.Int64_typeName
    if _newclass:typeName = staticmethod(_primitives.Int64_typeName)
    def __str__(self): return _primitives.Int64___str__(self)
    def __eq__(self, *args): return _primitives.Int64___eq__(self, *args)
    def __ne__(self, *args): return _primitives.Int64___ne__(self, *args)
    def __lt__(self, *args): return _primitives.Int64___lt__(self, *args)
    def __gt__(self, *args): return _primitives.Int64___gt__(self, *args)
    def __ge__(self, *args): return _primitives.Int64___ge__(self, *args)
    def __le__(self, *args): return _primitives.Int64___le__(self, *args)
    def __repr__(self): return _primitives.Int64___repr__(self)
    __swig_destroy__ = _primitives.delete_Int64
    __del__ = lambda self : None;
Int64_swigregister = _primitives.Int64_swigregister
Int64_swigregister(Int64)

def Int64_type():
  return _primitives.Int64_type()
Int64_type = _primitives.Int64_type

def Int64_typeName():
  return _primitives.Int64_typeName()
Int64_typeName = _primitives.Int64_typeName

class UInt64(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UInt64, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UInt64, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (long(args[0]),)
            except:
                raise TypeError("'long' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_UInt64(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.UInt64_value_set
    __swig_getmethods__["value"] = _primitives.UInt64_value_get
    if _newclass:value = _swig_property(_primitives.UInt64_value_get, _primitives.UInt64_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.UInt64_type
    if _newclass:type = staticmethod(_primitives.UInt64_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.UInt64_typeName
    if _newclass:typeName = staticmethod(_primitives.UInt64_typeName)
    def __str__(self): return _primitives.UInt64___str__(self)
    def __eq__(self, *args): return _primitives.UInt64___eq__(self, *args)
    def __ne__(self, *args): return _primitives.UInt64___ne__(self, *args)
    def __lt__(self, *args): return _primitives.UInt64___lt__(self, *args)
    def __gt__(self, *args): return _primitives.UInt64___gt__(self, *args)
    def __ge__(self, *args): return _primitives.UInt64___ge__(self, *args)
    def __le__(self, *args): return _primitives.UInt64___le__(self, *args)
    def __repr__(self): return _primitives.UInt64___repr__(self)
    __swig_destroy__ = _primitives.delete_UInt64
    __del__ = lambda self : None;
UInt64_swigregister = _primitives.UInt64_swigregister
UInt64_swigregister(UInt64)

def UInt64_type():
  return _primitives.UInt64_type()
UInt64_type = _primitives.UInt64_type

def UInt64_typeName():
  return _primitives.UInt64_typeName()
UInt64_typeName = _primitives.UInt64_typeName

class Float(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Float, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Float, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (float(args[0]),)
            except:
                raise TypeError("'float' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_Float(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.Float_value_set
    __swig_getmethods__["value"] = _primitives.Float_value_get
    if _newclass:value = _swig_property(_primitives.Float_value_get, _primitives.Float_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.Float_type
    if _newclass:type = staticmethod(_primitives.Float_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.Float_typeName
    if _newclass:typeName = staticmethod(_primitives.Float_typeName)
    def __str__(self): return _primitives.Float___str__(self)
    def __eq__(self, *args): return _primitives.Float___eq__(self, *args)
    def __ne__(self, *args): return _primitives.Float___ne__(self, *args)
    def __lt__(self, *args): return _primitives.Float___lt__(self, *args)
    def __gt__(self, *args): return _primitives.Float___gt__(self, *args)
    def __ge__(self, *args): return _primitives.Float___ge__(self, *args)
    def __le__(self, *args): return _primitives.Float___le__(self, *args)
    def __repr__(self): return _primitives.Float___repr__(self)
    __swig_destroy__ = _primitives.delete_Float
    __del__ = lambda self : None;
Float_swigregister = _primitives.Float_swigregister
Float_swigregister(Float)

def Float_type():
  return _primitives.Float_type()
Float_type = _primitives.Float_type

def Float_typeName():
  return _primitives.Float_typeName()
Float_typeName = _primitives.Float_typeName

class Double(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Double, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (float(args[0]),)
            except:
                raise TypeError("'float' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_Double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.Double_value_set
    __swig_getmethods__["value"] = _primitives.Double_value_get
    if _newclass:value = _swig_property(_primitives.Double_value_get, _primitives.Double_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.Double_type
    if _newclass:type = staticmethod(_primitives.Double_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.Double_typeName
    if _newclass:typeName = staticmethod(_primitives.Double_typeName)
    def __str__(self): return _primitives.Double___str__(self)
    def __eq__(self, *args): return _primitives.Double___eq__(self, *args)
    def __ne__(self, *args): return _primitives.Double___ne__(self, *args)
    def __lt__(self, *args): return _primitives.Double___lt__(self, *args)
    def __gt__(self, *args): return _primitives.Double___gt__(self, *args)
    def __ge__(self, *args): return _primitives.Double___ge__(self, *args)
    def __le__(self, *args): return _primitives.Double___le__(self, *args)
    def __repr__(self): return _primitives.Double___repr__(self)
    __swig_destroy__ = _primitives.delete_Double
    __del__ = lambda self : None;
Double_swigregister = _primitives.Double_swigregister
Double_swigregister(Double)

def Double_type():
  return _primitives.Double_type()
Double_type = _primitives.Double_type

def Double_typeName():
  return _primitives.Double_typeName()
Double_typeName = _primitives.Double_typeName

class String(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, String, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, String, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (str(args[0]),)
            except:
                raise TypeError("'str' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_String(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.String_value_set
    __swig_getmethods__["value"] = _primitives.String_value_get
    if _newclass:value = _swig_property(_primitives.String_value_get, _primitives.String_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.String_type
    if _newclass:type = staticmethod(_primitives.String_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.String_typeName
    if _newclass:typeName = staticmethod(_primitives.String_typeName)
    def __str__(self): return _primitives.String___str__(self)
    def __eq__(self, *args): return _primitives.String___eq__(self, *args)
    def __ne__(self, *args): return _primitives.String___ne__(self, *args)
    def __lt__(self, *args): return _primitives.String___lt__(self, *args)
    def __gt__(self, *args): return _primitives.String___gt__(self, *args)
    def __ge__(self, *args): return _primitives.String___ge__(self, *args)
    def __le__(self, *args): return _primitives.String___le__(self, *args)
    def __repr__(self): return _primitives.String___repr__(self)
    __swig_destroy__ = _primitives.delete_String
    __del__ = lambda self : None;
String_swigregister = _primitives.String_swigregister
String_swigregister(String)

def String_type():
  return _primitives.String_type()
String_type = _primitives.String_type

def String_typeName():
  return _primitives.String_typeName()
String_typeName = _primitives.String_typeName

class ByteString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ByteString, name)
    def __init__(self, *args): 
        """
        Construct a primitive.
        """
        if len(args) == 1:
            try:
                args = (bytearray(args[0]),)
            except:
                raise TypeError("'bytearray' expected instead of %s instance" %type(args[0]))
        elif len(args) > 0:
            raise TypeError("Only one value can be provided")


        this = _primitives.new_ByteString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["value"] = _primitives.ByteString_value_set
    __swig_getmethods__["value"] = _primitives.ByteString_value_get
    if _newclass:value = _swig_property(_primitives.ByteString_value_get, _primitives.ByteString_value_set)
    __swig_getmethods__["type"] = lambda x: _primitives.ByteString_type
    if _newclass:type = staticmethod(_primitives.ByteString_type)
    __swig_getmethods__["typeName"] = lambda x: _primitives.ByteString_typeName
    if _newclass:typeName = staticmethod(_primitives.ByteString_typeName)
    def __str__(self): return _primitives.ByteString___str__(self)
    def __eq__(self, *args): return _primitives.ByteString___eq__(self, *args)
    def __ne__(self, *args): return _primitives.ByteString___ne__(self, *args)
    def __lt__(self, *args): return _primitives.ByteString___lt__(self, *args)
    def __gt__(self, *args): return _primitives.ByteString___gt__(self, *args)
    def __ge__(self, *args): return _primitives.ByteString___ge__(self, *args)
    def __le__(self, *args): return _primitives.ByteString___le__(self, *args)
    def __repr__(self): return _primitives.ByteString___repr__(self)
    __swig_destroy__ = _primitives.delete_ByteString
    __del__ = lambda self : None;
ByteString_swigregister = _primitives.ByteString_swigregister
ByteString_swigregister(ByteString)

def ByteString_type():
  return _primitives.ByteString_type()
ByteString_type = _primitives.ByteString_type

def ByteString_typeName():
  return _primitives.ByteString_typeName()
ByteString_typeName = _primitives.ByteString_typeName

# This file is compatible with both classic and new-style classes.


